# This script manages all the running module commands

# Imports
import json
import os
import signal
import subprocess
import db_manager
import tempfile
from threading import Thread, Lock
import global_params
import xmltodict

# Global
COMMANDS_DICT = {  # Example fill
    # '211002': {  # The key is the command key, module key, and the parent key combined:
    #         # In example, command key = 2, module key = 1, parent key = 1002
    #     'running': True,  # Tells the command to keep running. Changing this to false should make the command stop
    #     'output': ''  # Saves the output of the command so far
    #     'process': p  # Saves the current running process variable
    #     'interrupted': False  # So we know if the command was stopped mid-execution or completed running
    # }
}
# A lock for the threads, so they don't read/write from the dictionary simultaneously
lock = Lock()


def fix_command(cmd: str, module_key: str):
    """
    Gets a command and checks if it is a command that requires saving to a file to get pretty output in the front end.
    If the command needs to save to a file for pretty output, edit the command and save to a temp file
    (gets deleted after command execution and saving nice output to db)
    :return: The edited command and the temp file
    """
    new_cmd = cmd
    temp_file = None
    # If command is Nmap
    if module_key == '1' and ' -oX ' in new_cmd:
        new_cmd = ''
        temp_file = tempfile.NamedTemporaryFile(dir=global_params.MODULE_COMMANDS_FOLDER)
        filename_next = False
        for part in ' '.join(cmd.split()).split(' '):  # Making all whitespaces 1 space
            if filename_next:
                new_cmd = new_cmd + ' ' + temp_file.name
                filename_next = False
                continue
            if part == '-oX':
                filename_next = True
            new_cmd = new_cmd + ' ' + part

    # Removing whitespace from beginning and end of the command
    # new_cmd = new_cmd.strip()

    return new_cmd, temp_file


def fix_command_output(cmd_output: str, module_key: str):
    """
    Gets the commands shell output or commands output to file and rearranges it to work well with the front end
    :param module_key: The key of the module, allowing us to edit the output according to the module
    :param cmd_output: The output of the module command, or the contents of the shell
    :return: Updated output to save as module_specific_data in the db
    """
    new_output = cmd_output
    if module_key == '1':  # If module is Nmap
        try:
            new_output = []
            content = xmltodict.parse(cmd_output)
            if type(content['nmaprun']['host']) == dict:
                for port in content['nmaprun']['host']['ports']['port']:
                    service = port['service']['@name']
                    if '@product' in port['service']:
                        service = service + ' ' + port['service']['@product']
                        if '@version' in port['service']:
                            service = service + ' ' + port['service']['@version']
                        if '@extrainfo' in port['service']:
                            service = service + ' ' + port['service']['@extrainfo']
                    new_output.append({
                        'key': port['@portid'] + port['@protocol'],
                        'port': port['@portid'],
                        'type': port['@protocol'],
                        'state': port['state']['@state'],
                        'service': service
                    })
                new_output = json.dumps(new_output)
        except Exception as e:
            new_output = 'Ran into an error while parsing nmap xml file output'
            print(e)

    return new_output


def get_command_current_output(cmd_key: str):
    """
    Gets a command key in the dictionary and returns the current output it has
    :param cmd_key: The dictionary command key
    :return: output or message
    """
    lock.acquire()
    if cmd_key in COMMANDS_DICT:
        current_output = COMMANDS_DICT[cmd_key]['output']
        lock.release()
        return current_output
    lock.release()
    return 'command is not running'


def get_current_commands_amount():
    """
    :return: A dictionary containing all the currently running commands
    """
    cmds_count = 0
    lock.acquire()
    for identifiers, values in COMMANDS_DICT.items():  # Go over all the commands
        if values['running']:  # Only get commands that are running
            cmds_count += 1
    lock.release()
    return cmds_count


def stop_command(cmd_key: str):
    """
    Change the commands 'running' state to false on user request to stop the commands execution
    :param cmd_key: The key of the command in the dictionary we are going to stop
    :return: A message indicating what happened
    """
    lock.acquire()
    if cmd_key in COMMANDS_DICT:
        p = COMMANDS_DICT[cmd_key]['process']
        lock.release()
        # Closing process properly
        # p.stdout.close()
        # p.stderr.close()
        # p.wait()
        # p.terminate()
        # We have to close the process in the following way because we allowed shell=True
        # When simply doing p.terminate() or p.kill() , it kills the shell process but not the command that is still running
        # This is why we add the preexec_fn=os.setsid to the Popen
        # I read about it on this page:
        # https://stackoverflow.com/questions/4789837/how-to-terminate-a-python-subprocess-launched-with-shell-true
        os.killpg(os.getpgid(p.pid), signal.SIGTERM)
        lock.acquire()
        COMMANDS_DICT[cmd_key]['running'] = False
        COMMANDS_DICT[cmd_key]['interrupted'] = True
        lock.release()
        return 'stopping command'
    lock.release()
    return 'command is not running'


def execute(cmd_dict: dict, temp_file):
    """
    Gets a dictionary  required parameters to run a command
    :param cmd_dict: A dictionary containing all command requirements
    :param temp_file: The temp file we created for the command
    :return:
    """
    # Getting all the relevant parameters for the command to run
    cmd = cmd_dict['command']
    working_directory = cmd_dict['workingDirectory']
    shell_executable = cmd_dict['executable']
    command_dict_key = cmd_dict['commandKey'] + cmd_dict['moduleKey'] + cmd_dict['parentKey']

    # Running command
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE,
                         universal_newlines=True, cwd=working_directory, shell=True, executable=shell_executable,
                         preexec_fn=os.setsid)
    lock.acquire()
    # Saving the commands status to the COMMANDS_DICT
    COMMANDS_DICT[command_dict_key] = {'running': True, 'output': '', 'process': p, 'interrupted': False}
    lock.release()

    while True:
        stdout_line = p.stdout.readline()
        if not stdout_line:  # If the command finished
            break
        lock.acquire()  # Waiting to get thread lock
        if not COMMANDS_DICT[command_dict_key]['running']:  # If the command should stop running
            lock.release()
            break
        # Adding the commands output to the dictionary
        COMMANDS_DICT[command_dict_key]['output'] = COMMANDS_DICT[command_dict_key]['output'] + \
                                                    str(stdout_line)
        lock.release()
    # Closing process properly
    # p.stdout.close()
    # p.stderr.close()
    # p.wait()
    # p.terminate()
    # We have to close the process in the following way because we allowed shell=True
    # When simply doing p.terminate() or p.kill() , it kills the shell process but not the command that is still running
    # This is why we add the preexec_fn=os.setsid to the Popen
    # I read about it on this page:
    # https://stackoverflow.com/questions/4789837/how-to-terminate-a-python-subprocess-launched-with-shell-true
    os.killpg(os.getpgid(p.pid), signal.SIGTERM)

    # Get info from file if it is needed
    file_content = None
    lock.acquire()
    if temp_file is not None and COMMANDS_DICT[command_dict_key]['interrupted'] is False:
        lock.release()
        try:
            file_content = str(temp_file.read().decode())
            # Close and delete the file
            temp_file.close()
            # Rearranging file content if needed
            file_content = fix_command_output(file_content, cmd_dict['moduleKey'])
        except Exception as e:  # Just in case we run into some unexpected error while reading the file
            file_content = 'Ran into an error while reading the file added to the command\n' + \
                           'Try running the command again'
            print(e)
    else:
        lock.release()
    cmd_dict['fileContent'] = file_content

    lock.acquire()
    cmd_dict['commandOutput'] = COMMANDS_DICT[command_dict_key]['output']
    del COMMANDS_DICT[command_dict_key]
    lock.release()
    # Updating final output in DB
    db_manager.update_module_command_output(cmd_dict)


def run_command_main(cmd_dict: dict):
    # An example of the dict this function should receive:
    # {
    #     "parentKey": "1002",
    #     "moduleKey": "1",
    #     "command": "nmap 1.1.1.1",
    #     "commandTitle": ""
    # }

    # Getting the working directory and shell executable
    command_key, shell_executable, working_directory = db_manager.run_module_command(cmd_dict)
    # If the host does not exist
    if shell_executable is None and working_directory is None:
        return command_key
    cmd_dict['commandKey'] = str(command_key)
    cmd_dict['executable'] = shell_executable
    cmd_dict['workingDirectory'] = working_directory
    # Fixing the given command if needed
    cmd_dict['command'], temp_file = fix_command(cmd_dict['command'], cmd_dict['moduleKey'])
    # Start running the command
    t = Thread(target=execute, args=(cmd_dict, temp_file,))
    t.start()
    return {'result': 'running command', 'commandKey': cmd_dict['commandKey']}
