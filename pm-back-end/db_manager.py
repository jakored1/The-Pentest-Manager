# This will handle all interaction with the applications sqlite3 database


# Imports
import os
import json
from werkzeug.utils import secure_filename
import sqlite3
from time import sleep
from datetime import datetime
import global_params
import ntpath
import shutil


def create_db():

    # If the relevant files folder does not exist
    if not os.path.isdir(global_params.FILES_PATH):
        os.mkdir(global_params.FILES_PATH)

    # If the module commands folder does not exist create it
    if not os.path.isdir(global_params.MODULE_COMMANDS_FOLDER):
        os.mkdir(global_params.MODULE_COMMANDS_FOLDER)

    # Creating sqlite3 db
    connection = sqlite3.connect(global_params.DB_PATH)
    cursor = connection.cursor()
    # Creating table for menu tabs
    cursor.execute("""CREATE TABLE menu_tabs (tab_key TEXT, tab_name TEXT, tab_icon TEXT)""")
    # Adding data to the table
    menu_tabs = [('1', 'Projects', global_params.ICONS_DICTIONARY['ProjectsMenuTab']),
                 ('2', 'Modules', global_params.ICONS_DICTIONARY['ModulesMenuTab']),
                 ('3', 'Settings', global_params.ICONS_DICTIONARY['SettingsMenuTab'])]
    cursor.executemany("""INSERT INTO menu_tabs VALUES (?,?,?)""", menu_tabs)
    connection.commit()  # Saving data

    # Creating table for projects
    cursor.execute("""CREATE TABLE projects (project_key TEXT, project_name TEXT, project_icon TEXT, 
    parent_menu_tab_key TEXT, creation_time TEXT, project_folder TEXT, project_notes TEXT)""")
    # Adding data to the table (adding the Add Project option as a child to Projects)
    projects = [('100', 'Add Project', global_params.ICONS_DICTIONARY['AddProject'], '1', None, None, None)]
    cursor.executemany("INSERT INTO projects VALUES (?,?,?,?,?,?,?)", projects)
    connection.commit()  # Saving data

    # Creating table for hosts
    cursor.execute("""CREATE TABLE hosts (host_key TEXT, host_name TEXT, host_icon TEXT, parent_project TEXT, 
    host_identifiers TEXT, creation_time TEXT, note TEXT)""")

    # Creating table for general module information
    cursor.execute("""CREATE TABLE modules (module_key TEXT, module_name TEXT, module_description TEXT, 
    module_logo_path TEXT)""")
    # Adding default module config
    modules = []
    for module_key, module_details in global_params.MODULES_LIST.items():
        modules.append((module_key, module_details['moduleName'], module_details['moduleDescription'],
                        module_details['moduleLogoPath']))
    cursor.executemany("INSERT INTO modules VALUES (?,?,?,?)", modules)

    # Creating table to save module commands
    cursor.execute("""CREATE TABLE module_commands (module_command_key TEXT, module_command TEXT, 
    module_command_description TEXT, parent_module_key TEXT)""")
    # Adding default module commands
    module_commands = []
    for module_key, module_details in global_params.MODULES_LIST.items():
        for module_command in module_details['defaultCommands']:
            module_commands.append((module_command['moduleCommandKey'], module_command['moduleCommand'],
                                    module_command['moduleCommandDescription'], module_key))
    cursor.executemany("""INSERT INTO module_commands VALUES (?,?,?,?)""", module_commands)

    # Creating table to save user configurations
    cursor.execute("""CREATE TABLE settings (setting TEXT, value TEXT)""")
    # Adding datatype settings
    datatypes = []
    for datatype, details in global_params.DATATYPES.items():
        datatypes.append((datatype + 'Datatype', datatype))
        datatypes.append((datatype + 'DatatypeString', details['stringRepresentation']))
        datatypes.append((datatype + 'DatatypeDescription', details['description']))
    cursor.executemany("""INSERT INTO settings VALUES (?,?)""", datatypes)
    # Adding read file settings
    cursor.executemany("""INSERT INTO settings VALUES (?,?)""", [
        ('FileEncoding', global_params.FILE_ENCODING)
    ])
    # Adding terminal/shell settings
    cursor.executemany("""INSERT INTO settings VALUES (?,?)""", [
        ('Shell', global_params.DEFAULT_SHELL),
        ('ShellWorkingDirectory', global_params.SHELL_WORKING_DIRECTORY)
    ])

    # Creating a table to save project's and host's datatypes
    # There will only be strings (STRING) and files (FILE) here,
    # because the HOST datatype can only be one of the hosts identifiers
    cursor.execute("""CREATE TABLE datatypes (datatype TEXT, datatype_key TEXT, value TEXT, parent_project TEXT, 
    parent_host TEXT)""")

    # Creating a table to save all the module commands outputs
    cursor.execute("""CREATE TABLE module_commands_outputs (command_key TEXT, executed_command TEXT, 
    command_output TEXT, parent_host TEXT, start_time TEXT, finish_time TEXT, module_key TEXT, command_title TEXT, 
    module_specific_data TEXT, is_running TEXT)""")

    # Creating a table to save all the hosts terminal sessions
    cursor.execute("""CREATE TABLE terminals (terminal_key TEXT, session_data TEXT, parent_host_key TEXT, 
    creation_time TEXT, last_session_time TEXT)""")

    # Create a table to save all attack chains
    cursor.execute("""CREATE TABLE attack_chains (attack_chain_parent TEXT, attack_chain_content TEXT)""")

    connection.commit()  # Saving data
    connection.close()
    # I got errors in other functions that tables didn't exist and such, so after creating the DB I give it a second
    sleep(1)


def get_sidebar_content():
    # Fetching data from db and rearranging for the front end
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    main_tabs = cursor.execute("SELECT tab_key, tab_name, tab_icon FROM menu_tabs").fetchall()  # Getting tabs
    tabs_final = []
    for tab in main_tabs:
        # If this isn't the projects tab then we can just append the normal stuff and move on
        if tab[0] != '1':
            tabs_final.append({
                'key': tab[0],
                'label': tab[1],
                'icon': tab[2]
            })
            continue

        # Getting projects under specific tab
        projects = cursor.execute("""SELECT project_key, project_name, parent_menu_tab_key
                                     FROM projects WHERE parent_menu_tab_key=? AND project_key != '100'""",
                                  [tab[0]]).fetchall()
        projects_list = []
        # Going over projects in reverse so that the most recent projects are shown first
        for project in reversed(projects):
            # Getting hosts under project
            hosts = cursor.execute("""SELECT host_key, host_name, host_icon FROM hosts WHERE parent_project=?""",
                                   [project[0]]).fetchall()
            hosts_list = []
            # Going over hosts in reverse so that the most recent hosts are shown first
            for host in reversed(hosts):
                hosts_list.append({
                    'key': host[0],
                    'label': host[1],
                    'icon': host[2]
                })
            projects_list.append({
                'key': project[0],
                'label': project[1],
                'children': hosts_list
            })
        # Adding 'Add Project' in the end
        add_project_project = cursor.execute("""SELECT project_key, project_name, project_icon, parent_menu_tab_key
                                             FROM projects WHERE parent_menu_tab_key=? AND project_key == '100'""",
                                             [tab[0]]).fetchall()
        projects_list.append({'key': add_project_project[0][0], 'label': add_project_project[0][1],
                              'icon': add_project_project[0][2]})

        # Appending the projects
        tabs_final.append({
            'key': tab[0],
            'label': tab[1],
            'icon': tab[2],
            'children': projects_list
        })
    connection.close()
    return tabs_final


def create_project(project_info: dict):
    """
    Check what number the project_key should be,
    Create the project,
    Add the 'Add Host' host to the project,
    Check if there are any hosts to add to the project upon creation
    :param project_info: A dictionary containing all the info needed to create the project
    :return: Success or Error message to be displayed to the user
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Finding the smallest unused key possible
    existing_projects = cursor.execute("""SELECT project_key FROM projects WHERE project_key != '100' ORDER BY 
    project_key ASC""").fetchall()
    # The smallest project key can be 1000
    min_project_key = 1000
    new_project_key = min_project_key
    # If no projects were created yet, meaning this is the first
    if len(existing_projects) < 1:
        new_project_key = min_project_key
    # If this is not the first project
    if len(existing_projects) > 0:
        for project_key in existing_projects:
            if min_project_key < int(project_key[0]):
                new_project_key = min_project_key
                break
            min_project_key += 1000
            new_project_key = min_project_key
    parent_menu_tab_key = 1  # All projects are under the 'Project' menu tab
    project_icon = None  # User created projects don't have an icon
    project_name = project_info['projectName'].strip()
    project_creation_time = str(datetime.now()).split('.')[0]
    project_folder = os.path.join(global_params.FILES_PATH, str(new_project_key))
    project_notes = None

    # Adding project to db (creating it)
    new_project_info = [(str(new_project_key), project_name, project_icon, str(parent_menu_tab_key),
                         project_creation_time, project_folder, project_notes)]
    cursor.executemany("""INSERT INTO projects VALUES (?,?,?,?,?,?,?)""", new_project_info)
    connection.commit()  # Saving data

    # Creating a folder for the project, so we can save files with the Files datatype
    os.mkdir(project_folder)

    # Adding empty attack chain to the project
    cursor.executemany("INSERT INTO attack_chains VALUES (?,?)", [(str(new_project_key), None)])

    # Creating The first host in the project (the 'Add Host' host)
    new_project_add_host_key = new_project_key + 1
    add_host_name = 'Manage Project'
    add_host_icon = global_params.ICONS_DICTIONARY['ManageProject']
    add_host_parent_project = new_project_key
    add_host_identifiers = None
    add_host_creation_time = None
    add_host_notes = None
    add_host_host_info = [(str(new_project_add_host_key), add_host_name, add_host_icon, add_host_parent_project,
                           add_host_identifiers, add_host_creation_time, add_host_notes)]
    cursor.executemany("""INSERT INTO hosts VALUES (?,?,?,?,?,?,?)""", add_host_host_info)
    connection.commit()  # Saving data
    connection.close()

    # Creating a response for the user
    response = 'Project created'

    # If there are any hosts
    if project_info['hosts'] is not None:
        if len(project_info['hosts']) > 0:
            result = add_host(project_info['hosts'], add_host_parent_project)  # Adding hosts
            if result == "Hosts Added":
                response += ' with hosts'
            elif result == "Max hosts reached for this project":
                response += ' without hosts. Too many hosts entered, the max is 997 hosts per project'
            else:  # If some error happened when trying to add the hosts
                response += ' but ran into error adding hosts. You can add them again via the projects tab'

    sleep(0.5)  # Waiting after editing db to not get errors
    return response


def add_host(hosts_list: list, parent_project_key):
    """
    Function that gets a list of hosts to create and adds them to the db
    :return:
    """
    if len(hosts_list) <= 0:  # If no hosts were given
        return "You didn't give me any hosts"

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    hosts_key_list = cursor.execute("""SELECT host_key FROM hosts WHERE SUBSTR(host_key, -3) != '001' AND 
    parent_project=? ORDER BY host_key ASC""", [str(parent_project_key)]).fetchall()

    # The smallest host key can be the project key + the string '002'
    # If project key is '3', then the smallest host key possible is '3002'
    new_host_key = int(str(parent_project_key)[0] + '002')
    new_hosts_key_list = []
    if len(hosts_key_list) > 0:  # If there are hosts in the project
        for host in hosts_key_list:
            new_hosts_key_list.append(int(host[0]))

    # We will append to the db with this
    hosts_db_list = []
    # To add an attack chain for each host
    attack_chain_list = []
    # To add terminals for each host
    terminals_list = []
    # To check if we reached maximum possible hosts for the project
    max_hosts = False
    for host in hosts_list:
        host_name = host['host_name'].strip()
        host_identifiers = host['host_identifiers'].strip()
        host_icon = None
        host_creation_time = str(datetime.now()).split('.')[0]
        # Finding smallest unused host key
        if len(new_hosts_key_list) < 1:  # If there are no hosts yet
            new_hosts_key_list.append(new_host_key)
        elif len(new_hosts_key_list) > 0:  # If the project already has hosts in it
            while True:  # Going over new_hosts_key_list until we find the lowest unused host key
                # If we reached max hosts in project
                if new_host_key == int(parent_project_key) + 1000:
                    max_hosts = True
                    break
                # If the new_host_key is in the new_hosts_key_list list add 1 and check again
                # We do this until we reach a free new_host_key
                if new_host_key in new_hosts_key_list:
                    new_host_key += 1
                else:
                    break
        # If we can't add any more hosts
        if max_hosts:
            break
        # Adding host to host list
        new_hosts_key_list.append(new_host_key)
        # Adding host to db query list
        hosts_db_list.append((str(new_host_key), host_name, host_icon, str(parent_project_key), host_identifiers,
                              host_creation_time, None))

        # When creating a host, create an attack chain for it as well
        attack_chain_list.append((str(new_host_key), None))

        # When creating a host, create a terminal for it as well
        # The first terminal for each host will have the key 1 - what makes it unique is that it is the only terminal
        # with that terminal key whose parent host is new_host_key
        terminals_list.append(('1', None, str(new_host_key), host_creation_time, None))

        # Moving over to next host key
        new_host_key += 1

    # Adding hosts
    cursor.executemany("""INSERT INTO hosts VALUES (?,?,?,?,?,?,?)""", hosts_db_list)

    # Adding empty attack chain to the project
    cursor.executemany("INSERT INTO attack_chains VALUES (?,?)", attack_chain_list)

    # Adding terminal
    cursor.executemany("""INSERT INTO terminals VALUES (?,?,?,?,?)""", terminals_list)

    connection.commit()  # Saving data
    connection.close()
    sleep(0.5)  # Waiting after editing db to not get errors
    return "Hosts Added"


def get_project_info(host_key):
    """
    Gets the following info about the requested project,
    and returns it in a format that antd can turn to a table:
    1. A table of all the hosts in the project, with the option to update the hosts details easily via the table,
       and an option to delete the hosts
    2. Project general details
    3. Datatype objects associated to the project (files/strings)
    :param host_key: The key of the 'Manage Project' tab that was selected
    :return:
    """

    project_info = {}  # Json containing all the info
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    # Getting project info
    query = """SELECT project_key, project_name, creation_time, project_notes FROM projects
               WHERE project_key=?"""
    result = cursor.execute(query, [str(int(host_key) - 1)]).fetchall()[0]
    project_key = result[0]
    # Adding project info
    project_info['project'] = {
        'project_key': project_key,
        'project_name': result[1],
        'project_creation_datetime': result[2],
        'project_notes': result[3]
    }

    # Getting hosts info under project
    query = """SELECT host_key, host_name, host_identifiers, creation_time FROM hosts 
               WHERE parent_project=? AND host_key != ?"""
    project_hosts = cursor.execute(query, [project_key, str(host_key)]).fetchall()

    project_info['hosts'] = []
    for host in project_hosts:
        project_info['hosts'].append({
            'key': host[0],
            'host_name': host[1],
            'host_identifiers': host[2],
            'host_creation_time': host[3]
        })

    # Getting project files
    query = """SELECT datatype_key, value FROM datatypes WHERE datatype=? AND parent_project=?"""
    project_files = cursor.execute(query, ['File', project_key]).fetchall()
    # Get encoding to use
    encoding = cursor.execute("SELECT value FROM settings WHERE setting='FileEncoding'").fetchall()[0][0]
    # Organizing files info
    files_list = []
    for file in project_files:
        file_key = file[0]
        file_path = file[1]
        file_name = str(file_path).split('/')[-1]
        last_modified = datetime.utcfromtimestamp(os.path.getmtime(file_path)).strftime('%Y-%m-%d %H:%M:%S')
        file_size_bytes = int(os.stat(file_path).st_size)
        file_size_kb = file_size_bytes / 1024
        file_size_mb = file_size_kb / 1024
        file_size_gb = file_size_mb / 1024
        full_file_path = os.path.join(os.getcwd(), file_path)
        # file_size_readable = str(file_size_mb).split('.')[0] + '.' + str(file_size_mb).split('.')[1][0:3] + ' MB'
        file_size_readable = str(file_size_bytes) + ' bytes'
        # Getting file contents
        with open(file_path, 'r', encoding=encoding) as f:
            file_content = f.read()
        files_list.append({
            'key': file_key,
            'name': file_name,
            'size': file_size_readable,
            'last_modified': last_modified,
            'file_content': file_content,
            'full_file_path': full_file_path
        })
    project_info['files'] = files_list

    # Getting strings info
    query = """SELECT datatype_key, value FROM datatypes WHERE datatype=? AND parent_project=?"""
    project_strings = cursor.execute(query, ['String', project_key]).fetchall()
    strings_list = []
    for project_string in project_strings:
        strings_list.append({'key': project_string[0], 'string': project_string[1]})
    project_info['strings'] = strings_list

    # Getting attack chain info
    attack_chain = cursor.execute("SELECT attack_chain_content FROM attack_chains WHERE attack_chain_parent=?",
                                  [project_key]).fetchall()[0][0]
    project_info['attack_chain'] = attack_chain

    connection.close()
    return project_info


def update_host(host_info: dict):
    """
    Gets a dictionary representing updated host info of an already existing host,
    Makes sure the host exists in the database and then updates its contents accordingly
    :param host_info: A dictionary representing updated host
    :return: Message depending on functions results
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Check if the host exists
    query = """SELECT host_key FROM hosts WHERE host_key=?"""
    result = cursor.execute(query, [host_info['key']]).fetchall()
    if len(result) != 1:  # If there is no host with that key
        connection.close()
        return 'A host with the given key does not exist'
    # Update the host
    query = """UPDATE hosts SET host_identifiers=?, host_name=? WHERE host_key=?"""
    cursor.execute(query, [host_info['host_identifiers'].strip(), host_info['host_name'].strip(), host_info['key']])
    connection.commit()
    connection.close()
    return 'Host updated'


def delete_host(host_key: dict):
    """
    Deletes the host whose key equals to host_key
    :param host_key: A dictionary that contains the key of the host we want to delete.
    looks like this {'key': 'HOST_KEY'}
    :return: A message according to the result of the action
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    # Checking that host exists
    query = """SELECT host_key FROM hosts WHERE host_key=?"""
    r = cursor.execute(query, [host_key['key']]).fetchall()
    if len(r) != 1:
        connection.close()
        return "Host does not exist"
    # Making sure there are no running commands in the host
    r = cursor.execute("SELECT command_key FROM module_commands_outputs WHERE parent_host=? AND is_running='true'",
                       [host_key['key']]).fetchall()
    if len(r) > 0:
        connection.close()
        return "The host has running commands, close them before deleting the host"

    # Deleting module commands executed on host
    cursor.execute("DELETE FROM module_commands_outputs WHERE parent_host=?", [host_key['key']])
    # Deleting attack chains that belong to the host
    cursor.execute("DELETE FROM attack_chains WHERE attack_chain_parent=?", [host_key['key']])
    # Deleting terminal sessions that belong to the host
    cursor.execute("DELETE FROM terminals WHERE parent_host_key=?", [host_key['key']])

    # Delete the host from the database
    query = """DELETE FROM hosts WHERE host_key=?"""
    cursor.execute(query, [host_key['key']])
    connection.commit()
    connection.close()
    return 'Host deleted'


def delete_project(project_key: dict):
    """
    Deletes a project and all the hosts that belong to it
    :param project_key: A dictionary that contains the key of the host we want to delete.
    looks like this {'key': 'PROJECT_KEY'}
    :return: A message according to the result of the action
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    # Checking that project exists
    query = """SELECT project_key FROM projects WHERE project_key=?"""
    r = cursor.execute(query, [project_key['key']]).fetchall()
    if len(r) != 1:
        connection.close()
        return "Project does not exist"
    # Making sure the hosts in the project don't have any running commands
    hosts = cursor.execute("""SELECT host_key FROM hosts WHERE parent_project=?""", [project_key['key']]).fetchall()
    query = "SELECT command_key FROM module_commands_outputs WHERE is_running='true' AND parent_host IN ("
    for host in hosts:
        query = query + "'" + host[0] + "', "
    query = query[0:-2] + ")"
    # Making sure there are no running commands in the host
    r = cursor.execute(query).fetchall()
    if len(r) > 0:
        connection.close()
        return "One or more of the hosts in this project has running commands, close them before deleting the project"

    # Getting project folder path
    project_path = cursor.execute("SELECT project_folder FROM projects WHERE project_key=?",
                                  [project_key['key']]).fetchall()[0][0]
    # Deleting all the files in the project folder
    for root, dirs, files in os.walk(project_path):
        for file in files:
            os.remove(os.path.join(root, file))
    # Deleting project folder
    os.rmdir(project_path)

    # Deleting any datatype objects associated with the project
    cursor.execute("""DELETE FROM datatypes WHERE parent_project=?""", [project_key['key']])

    # Deleting attack chains that belong to the project
    cursor.execute("DELETE FROM attack_chains WHERE attack_chain_parent=?", [project_key['key']])

    # Delete the project from the database
    query = """DELETE FROM projects WHERE project_key=?"""
    cursor.execute(query, [project_key['key']])

    # Get a list of all the hosts in the project,
    # so we can delete any module commands and terminals associated to them
    project_hosts = cursor.execute("SELECT host_key FROM hosts WHERE parent_project=?",
                                   [project_key['key']]).fetchall()
    for host in project_hosts:
        host_key = host[0]
        # Deleting module commands executed on host
        cursor.execute("DELETE FROM module_commands_outputs WHERE parent_host=?", [host_key])
        # Deleting attack chains that belong to the host
        cursor.execute("DELETE FROM attack_chains WHERE attack_chain_parent=?", [host_key])
        # Deleting terminal sessions that belong to the host
        cursor.execute("DELETE FROM terminals WHERE parent_host_key=?", [host_key])

    # Delete all the hosts in the project
    query = """DELETE FROM hosts WHERE parent_project=?"""
    cursor.execute(query, [project_key['key']])

    connection.commit()
    connection.close()
    return 'Project deleted'


def get_module_image_path(module_key):
    """
    Gets a module key and returns the path to it's image
    :param module_key: The module's key
    :return: Path to the modules logo
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    image_path = cursor.execute("""SELECT module_logo_path FROM modules WHERE module_key=?""", [module_key]).fetchall()
    connection.close()

    if len(image_path) == 1:
        return image_path[0][0]

    return "Could not find modules image"


def get_modules_list():
    """
    Returns a list of all the modules and there info for the front end
    :return: A list of all the modules and there info for the front end
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    modules = cursor.execute("""SELECT module_key, module_name, module_description FROM modules""").fetchall()
    connection.close()

    modules_list = []
    for module in modules:
        modules_list.append({
            'key': module[0],
            'name': module[1],
            'icon': 'http://' + global_params.BACKEND_IP + ':' + str(global_params.BACKEND_PORT) +
                    '/moduleImage?image=' + module[0],
            'description': module[2]
        })

    return modules_list


def get_module_info(module_key):
    """
    Gets all the saved commands of a certain module and general module info
    :return:
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    # Getting the modules general info
    query = "SELECT module_key, module_name, module_description FROM modules WHERE module_key=?"
    module_info = cursor.execute(query, [module_key]).fetchall()

    if len(module_info) != 1:  # If there is no such module
        connection.close()
        return "Could not find module matching that key"

    query = "SELECT module_command_key, module_command, module_command_description FROM module_commands WHERE " \
            "parent_module_key=?"
    module_commands = cursor.execute(query, [module_key]).fetchall()
    connection.close()

    module_info_dict = {
        'key': module_info[0][0],
        'name': module_info[0][1],
        'description': module_info[0][2],
        'commands': []
    }

    for command in module_commands:
        module_info_dict['commands'].append({
            'key': command[0],
            'command': command[1],
            'description': command[2]
        })

    return module_info_dict


def update_module_command(module_command_dict: dict):
    """
    Gets a dictionary containing a module's command info and updates it in the database
    :param module_command_dict: A dictionary containing a module's command
    :return: Success or not
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure module command exists
    query = "SELECT * FROM module_commands WHERE module_command_key=? AND parent_module_key=?"
    result = cursor.execute(query, [module_command_dict['command']['key'], module_command_dict['moduleKey']]).fetchall()

    if len(result) != 1:
        connection.close()
        return "Module does not contain selected command"

    query = "UPDATE module_commands SET module_command=?, module_command_description=? WHERE module_command_key=? " \
            "AND parent_module_key=?"
    cursor.execute(query, [module_command_dict['command']['command'], module_command_dict['command']['description'],
                           module_command_dict['command']['key'], module_command_dict['moduleKey']])
    connection.commit()
    connection.close()
    return 'Command updated'


def delete_module_command(module_command_dict: dict):
    """
    Get a dictionary containing a module's command info and deletes the command
    :param module_command_dict: A dictionary containing a module's command info
    :return: Message representing what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure module command exists
    query = "SELECT * FROM module_commands WHERE module_command_key=? AND parent_module_key=?"
    result = cursor.execute(query, [module_command_dict['command']['key'], module_command_dict['moduleKey']]).fetchall()

    if len(result) != 1:
        connection.close()
        return "Module does not contain selected command"

    query = "DELETE FROM module_commands WHERE module_command_key=? AND parent_module_key=?"
    cursor.execute(query, [module_command_dict['command']['key'], module_command_dict['moduleKey']])
    connection.commit()
    connection.close()
    return 'Command deleted'


def add_module_command(module_key: dict):
    """
    Gets a module key and adds a command with default entries to the module's commands
    :param module_key: The key of the module we will add a command to
    :return: JSON containing the info needed for the front end to add it as a table object
    """

    connection = sqlite3.connect(global_params.DB_PATH)
    cursor = connection.cursor()

    # Making sure module exists
    query = "SELECT * FROM modules WHERE module_key=?"
    result = cursor.execute(query, [module_key['moduleKey']]).fetchall()

    if len(result) != 1:
        connection.close()
        return "Module does not exist"

    # Finding minimum module command key
    query = """SELECT module_command_key FROM module_commands WHERE parent_module_key=? ORDER BY 
    CAST(module_command_key as INTEGER) ASC"""
    module_commands = cursor.execute(query, [module_key['moduleKey']]).fetchall()

    minimum_command_key = 1
    # If the module has some commands
    if len(module_commands) > 0:
        for command in module_commands:
            command_key = int(command[0])
            # If this key is free it's the new commands key
            if minimum_command_key != command_key:
                break
            # If the key was taken then add one and try again
            minimum_command_key += 1

    # Adding new command
    data = [(str(minimum_command_key), '# new command', 'Your new command', module_key['moduleKey'])]
    cursor.executemany("INSERT INTO module_commands VALUES (?,?,?,?)", data)
    connection.commit()
    connection.close()

    front_end_table_row_data = {
        "key": (str(minimum_command_key)),
        "command": "# new command",
        "description": "Your new command"
    }

    return front_end_table_row_data


def get_command_datatypes():
    """
    Returns each datatypes information
    :return:
    """

    connection = sqlite3.connect(global_params.DB_PATH)
    cursor = connection.cursor()

    datatypes = {
        'Host': {'name': '', 'stringRepresentation': '', 'description': ''},
        'String': {'name': '', 'stringRepresentation': '', 'description': ''},
        'File': {'name': '', 'stringRepresentation': '', 'description': ''}
    }
    # Get host datatype
    r = cursor.execute("""SELECT setting, value FROM settings WHERE setting LIKE 'HostDatatype%' """).fetchall()
    datatypes['Host']['name'] = r[0][1]
    datatypes['Host']['stringRepresentation'] = r[1][1]
    datatypes['Host']['description'] = r[2][1]
    # Get string datatype
    r = cursor.execute("""SELECT setting, value FROM settings WHERE setting LIKE 'StringDatatype%' """).fetchall()
    datatypes['String']['name'] = r[0][1]
    datatypes['String']['stringRepresentation'] = r[1][1]
    datatypes['String']['description'] = r[2][1]
    # Get file datatype
    r = cursor.execute("""SELECT setting, value FROM settings WHERE setting LIKE 'FileDatatype%' """).fetchall()
    datatypes['File']['name'] = r[0][1]
    datatypes['File']['stringRepresentation'] = r[1][1]
    datatypes['File']['description'] = r[2][1]
    connection.close()

    return datatypes


def save_settings_changes(settings_dict: dict):
    """
    Get a dictionary representing updated settings, update the db contents accordingly.
    If there was a change to one of the datatype strings, go over every module's command and update it
    :param settings_dict: A dictionary representing updated settings
    :return: Message representing what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)
    cursor = connection.cursor()

    # Checking if one of the datatype strings was changed
    datatype_is_different = False
    host_string = cursor.execute("SELECT value FROM settings WHERE setting='HostDatatypeString'").fetchall()[0][0]
    file_string = cursor.execute("SELECT value FROM settings WHERE setting='FileDatatypeString'").fetchall()[0][0]
    string_string = cursor.execute("SELECT value FROM settings WHERE setting='StringDatatypeString'").fetchall()[0][0]
    if settings_dict['hostDatatype'] != host_string or settings_dict['stringDatatype'] != string_string \
            or settings_dict['fileDatatype'] != file_string:
        datatype_is_different = True

    # If one of the datatype strings was edited
    if datatype_is_different:
        # Updating datatype strings
        cursor.execute("UPDATE settings SET value=? WHERE setting='HostDatatypeString'",
                       [settings_dict['hostDatatype']])
        cursor.execute("UPDATE settings SET value=? WHERE setting='StringDatatypeString'",
                       [settings_dict['stringDatatype']])
        cursor.execute("UPDATE settings SET value=? WHERE setting='FileDatatypeString'",
                       [settings_dict['fileDatatype']])
        # Going over all module's commands to update the datatype string to the new one
        cursor.execute("""UPDATE module_commands SET module_command = replace(module_command, '""" + host_string +
                       """', '""" + settings_dict['hostDatatype'] + """') WHERE module_command LIKE '%""" + host_string
                       + """%'""")
        cursor.execute("""UPDATE module_commands SET module_command = replace(module_command, '""" + file_string +
                       """', '""" + settings_dict['fileDatatype'] + """') WHERE module_command LIKE '%""" + file_string
                       + """%'""")
        cursor.execute("""UPDATE module_commands SET module_command = replace(module_command, '""" + string_string +
                       """', '""" + settings_dict['stringDatatype'] + """') WHERE module_command LIKE '%""" +
                       string_string + """%'""")
    # Updating shell
    shell_updated = False
    # Making sure given path is a file
    if shutil.which(settings_dict['shell']) is not None:
        cursor.execute("UPDATE settings SET value=? WHERE setting='Shell'", [settings_dict['shell']])
        shell_updated = True

    # Updating working directory
    working_directory_updated = False
    # Making sure new directory exists
    if os.path.isdir(settings_dict['shellWorkingDirectory']):
        cursor.execute("UPDATE settings SET value=? WHERE setting='ShellWorkingDirectory'",
                       [settings_dict['shellWorkingDirectory']])
        working_directory_updated = True

    # Updating encoding
    cursor.execute("UPDATE settings SET value=? WHERE setting='FileEncoding'", [settings_dict['encoding']])

    connection.commit()
    connection.close()

    if not working_directory_updated and not shell_updated:
        return "The path entered as a shell is not an executable or does not exist, The path entered for working " \
               "directory is not a directory, All other settings were updated"
    if not working_directory_updated:
        return "The path entered for working directory is not a directory, All other settings were updated"
    if not shell_updated:
        return "The path entered as a shell is not an executable or does not exist, All other settings were updated"

    return "settings updated"


def get_settings():
    """
    Returns all configurable settings
    :return: A dictionary containing all configurable settings
    """
    connection = sqlite3.connect(global_params.DB_PATH)
    cursor = connection.cursor()
    settings = cursor.execute("""SELECT value FROM settings WHERE setting IN ('HostDatatype', 'HostDatatypeString', 
    'HostDatatypeDescription', 'StringDatatype', 'StringDatatypeString', 'StringDatatypeDescription', 
    'FileDatatype', 'FileDatatypeString', 'FileDatatypeDescription', 'FileEncoding', 'Shell', 
    'ShellWorkingDirectory')""").fetchall()

    settings_dict = {
        'Datatypes': {
            'Host': {
                'name': settings[0][0],
                'stringRepresentation': settings[1][0],
                'description': settings[2][0]
            },
            'String': {
                'name': settings[3][0],
                'stringRepresentation': settings[4][0],
                'description': settings[5][0]
            },
            'File': {
                'name': settings[6][0],
                'stringRepresentation': settings[7][0],
                'description': settings[8][0]
            },
        },
        'Encoding': settings[9][0],
        'Shell': settings[10][0],
        'ShellWorkingDirectory': settings[11][0]
    }

    connection.close()
    return settings_dict


def delete_file(file_dict: dict):
    """
    Get a file to delete and deletes it from the db, and the file itself
    :param file_dict: File details
    :return: An indicative message
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure file exists
    query = "SELECT value FROM datatypes WHERE datatype_key=?"
    file_path = cursor.execute(query, [file_dict['key']]).fetchall()

    if len(file_path) != 1:
        connection.close()
        return "file does not exist"

    # Deleting file from project folder
    os.remove(file_path[0][0])
    # Deleting file from db
    query = "DELETE FROM datatypes WHERE datatype_key=?"
    cursor.execute(query, [file_dict['key']])
    connection.commit()
    connection.close()

    return 'file deleted'


def edit_file(file_dict: dict):
    """
    Gets updated info of an existing file and updates it with the users content
    :param file_dict: A dictionary containing the updated file's info
    :return: A indicative message about what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Finding the original files contents
    r = cursor.execute("""SELECT value FROM datatypes WHERE datatype_key=?""", [file_dict['key']]).fetchall()[0]

    # If file does not exist
    if len(r) != 1:
        connection.close()
        return 'the file you tried to update does not exist'

    file_path = r[0]
    # If the file doesn't exist in the files folder
    if not os.path.isfile(file_path):
        # If we're here it means that the file exists in the DB but not in the folder,
        # Therefore the files contents are lost
        # So we will simply delete the file's entry in the DB and return a message that the file doesn't exist
        cursor.execute("DELETE FROM datatypes WHERE datatype_key=?", [file_dict['key']])
        connection.commit()
        connection.close()
        return 'the file you tried to update does not exist'

    # After all the validations we update the file
    # Get encoding to use
    encoding = cursor.execute("SELECT value FROM settings WHERE setting='FileEncoding'").fetchall()[0][0]
    try:
        # Update the files contents
        with open(file_path, 'w', encoding=encoding) as f:
            f.write(file_dict['file_content'])
        # Rename the file
        old_file_name = ntpath.basename(file_path)
        new_file_name = str(file_path).replace(old_file_name, file_dict['file_name'])
        os.rename(file_path, new_file_name)

        # Update the DB entry
        cursor.execute("UPDATE datatypes SET value=? WHERE datatype_key=?", [new_file_name, file_dict['key']])
        connection.commit()
        connection.close()
        return 'file updated'

    except Exception as e:
        print(e)
        connection.close()
        return 'ran into an error while updating the file'


def create_file(file_dict: dict):
    """
    Get details of a file to create, creates the file with requested contents and adds it to the DB
    :param file_dict: A Dictionary containing all the information required to create a file
    :return: A message indicating what happened, or a json of the newly created so the front end can add it to the table
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Checking if this project has a file with the same name
    project_files = cursor.execute("SELECT value FROM datatypes WHERE parent_project=?",
                                   [file_dict['project_key']]).fetchall()
    for file in project_files:
        file_name = ntpath.basename(file[0])
        # If the names match
        if file_name == file_dict['file_name']:
            connection.close()
            return 'A file already exists with that name'

    # After passing validation we can start adding to DB
    # Finding the smallest available datatype_key
    datatype_keys = cursor.execute("""SELECT datatype_key FROM datatypes 
    ORDER BY CAST(datatype_key as INTEGER) ASC""").fetchall()
    minimum_datatype_key = 1
    # If a datatype already exists
    if len(datatype_keys) > 0:
        for datatype in datatype_keys:
            datatype_key = int(datatype[0])
            # If this key is free it's the new file key
            if minimum_datatype_key != datatype_key:
                break
            # If the key was taken then add one and try again
            minimum_datatype_key += 1
    datatype_type = 'File'
    file_path = os.path.join(global_params.FILES_PATH, str(file_dict['project_key']), file_dict['file_name'])
    # Adding datatype to DB
    cursor.executemany("""INSERT INTO datatypes VALUES (?,?,?,?,?)""",
                       [(datatype_type, minimum_datatype_key, file_path, file_dict['project_key'], None)])
    connection.commit()

    # Creating file and writing data
    # Get encoding to use
    encoding = cursor.execute("SELECT value FROM settings WHERE setting='FileEncoding'").fetchall()[0][0]
    with open(file_path, 'w', encoding=encoding) as f:
        f.write(file_dict['file_content'])

    connection.close()
    return {
        "file_content": file_dict['file_content'],
        "key": str(minimum_datatype_key),
        "last_modified": datetime.utcfromtimestamp(os.path.getmtime(file_path)).strftime('%Y-%m-%d %H:%M:%S'),
        "name": file_dict['file_name'],
        "size": str(os.stat(file_path).st_size) + ' bytes'
    }


def upload_files(file_list: list, project_key):
    """
    Gets a list of files that were uploaded, saves them and adds them to the DB
    :param project_key: The project the files will be associated to
    :param file_list: A list of files to upload
    :return: A JSON containing each files status (a file that couldn't be saved will be mentioned there)
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # A list to save the result of every file save attempt, so we can return the data to the front end
    result_list = []
    # The cnt will represent which file had or didn't have errors in the front end
    cnt = 0
    # Iterating over files and trying to save them
    for file in file_list:
        file_name = secure_filename(file.filename)
        file_path = os.path.join(global_params.FILES_PATH, project_key, file_name)

        # Checking if there is are already files with one of the files names
        r = cursor.execute("SELECT value FROM datatypes WHERE datatype='File' AND value=?",
                           [file_path]).fetchall()
        # If there already is a file with that name
        if len(r) > 0:
            result_list.append({
                'position': str(cnt),
                'result': 'A file with that name already exists'
            })
            cnt += 1
            continue

        # After passing validation we can start adding to DB
        # Finding the smallest available datatype_key
        datatype_keys = cursor.execute("""SELECT datatype_key FROM datatypes ORDER BY CAST(datatype_key as INTEGER)
        ASC""").fetchall()
        minimum_datatype_key = 1
        # If a datatype already exists
        if len(datatype_keys) > 0:
            for datatype in datatype_keys:
                datatype_key = int(datatype[0])
                # If this key is free it's the new commands key
                if minimum_datatype_key != datatype_key:
                    break
                # If the key was taken then add one and try again
                minimum_datatype_key += 1
        # Adding to db
        try:
            cursor.executemany("""INSERT INTO datatypes VALUES (?,?,?,?,?)""",
                               [('File', minimum_datatype_key, file_path, project_key, None)])
            connection.commit()
            # Saving file in project folder
            file.save(file_path)
            # Getting file content
            with open(file_path, 'r') as f:
                file_content = f.read()
            result_list.append({
                'position': str(cnt),
                'result': {
                    "file_content": file_content,
                    "key": str(minimum_datatype_key),
                    "last_modified": datetime.utcfromtimestamp(os.path.getmtime(file_path)).strftime(
                        '%Y-%m-%d %H:%M:%S'),
                    "name": file_name,
                    "size": str(os.stat(file_path).st_size) + ' bytes'
                }
            })
        except Exception as e:
            print(e)
            result_list.append({
                'position': str(cnt),
                'result': 'Ran into an error when uploading the file'
            })
        cnt += 1
    connection.close()
    return result_list


def delete_string(string_dict: dict):
    """
    Gets a dictionary with strings info and deletes it from the DB
    :param string_dict: A dictionary containing the strings info
    :return: A message indicating what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure string exists
    r = cursor.execute("SELECT datatype_key FROM datatypes WHERE datatype_key=?", [string_dict['key']]).fetchall()
    if len(r) != 1:
        connection.close()
        return 'The key you wish to delete does not exist'

    # If the key does exist then lets delete it
    cursor.execute("DELETE FROM datatypes WHERE datatype_key=?", [string_dict['key']])
    connection.commit()
    connection.close()
    return 'string deleted'


def add_string(project_key: dict):
    """
    Gets a project key and adds a string datatype with default value to the project
    :param project_key: A dictionary containing the projects key
    :return: A dictionary containing strings info to be able to add it to the front end table
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Finding the smallest available datatype_key
    datatype_keys = cursor.execute("""SELECT datatype_key FROM datatypes 
        ORDER BY CAST(datatype_key as INTEGER) ASC""").fetchall()
    minimum_datatype_key = 1
    # If a datatype already exists
    if len(datatype_keys) > 0:
        for datatype in datatype_keys:
            datatype_key = int(datatype[0])
            # If this key is free it's the new datatype key
            if minimum_datatype_key != datatype_key:
                break
            # If the key was taken then add one and try again
            minimum_datatype_key += 1
    new_string = 'new string'
    # Adding datatype to DB
    cursor.executemany("INSERT INTO datatypes VALUES (?,?,?,?,?)",
                       [('String', minimum_datatype_key, new_string, project_key['projectKey'], None)])
    connection.commit()
    connection.close()
    return {
        'key': minimum_datatype_key,
        'string': new_string
    }


def update_string(string_dict: dict):
    """
    Gets new value of an existing string and updates it in the DB
    :param string_dict: A dictionary containing the strings new value
    :return: A message indicating what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure the string exists in the DB
    r = cursor.execute("SELECT datatype_key FROM datatypes WHERE datatype_key=?", [string_dict['key']]).fetchall()
    if len(r) != 1:
        connection.close()
        return 'The string that you are trying to update does not exist'

    # If the string does exist then we can update it
    cursor.execute("UPDATE datatypes SET value=? WHERE datatype_key=?", [string_dict['string'], string_dict['key']])
    connection.commit()
    connection.close()
    return 'string updated'


def get_host_info(host_key):
    """
    Gets a host's key and returns all the hosts info
    :param host_key: The requested host's key
    :return: A dictionary with all the hosts info
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Checking if host exists and getting host info
    host_details = cursor.execute("""SELECT host_name, host_identifiers, creation_time, note FROM hosts 
    WHERE host_key=?""", [host_key]).fetchall()
    # If a host that doesn't exist was requested
    if len(host_details) != 1:
        connection.close()
        return 'The requested host does not exist'

    # Getting host's terminal sessions
    terminal_sessions = cursor.execute("""SELECT terminal_key, session_data, creation_time, last_session_time FROM 
    terminals WHERE parent_host_key=?""", [host_key]).fetchall()
    terminal_sessions_list = []
    for session_info in terminal_sessions:
        terminal_sessions_list.append({
            'terminal_key': str(session_info[0]),
            'terminal_name': 'Terminal ' + str(session_info[0]),
            'session_data': session_info[1],
            'creation_time': session_info[2],
            'last_session_time': session_info[3]
        })

    # Getting a list of modules keys and names
    module_key_name_list = cursor.execute("SELECT module_key, module_name FROM modules").fetchall()
    module_key_name_dict = {}
    for module in module_key_name_list:
        module_key_name_dict[module[0]] = module[1]

    # Getting host's module commands outputs
    module_commands_output = cursor.execute("""SELECT command_key, executed_command, command_output, start_time, 
    module_key, module_specific_data, command_title, is_running, finish_time
    FROM module_commands_outputs WHERE parent_host=?""", [host_key]).fetchall()
    modules_dict = {}
    # Adding the modules that ran to the dict
    for command in module_commands_output:
        modules_dict[command[4]] = {
            'key': command[4],
            'name': module_key_name_dict[command[4]],
            'icon': 'http://' + global_params.BACKEND_IP + ':' + str(global_params.BACKEND_PORT) +
                    '/moduleImage?image=' + command[4],
            'commands': []
        }
    # Adding each module's commands
    for command in module_commands_output:
        # Checking command runtime
        if command[8] is None or str(command[8]).replace(' ', '') == '':  # If command did not finish executing
            if command[7] == 'true':
                command_runtime = 'command is still running'
            else:# if command[7] == 'false':
                command_runtime = 'command interrupted'
        else:
            command_finish_time = datetime.strptime(command[8], "%Y-%m-%d %H:%M:%S")
            command_start_time = datetime.strptime(command[3], "%Y-%m-%d %H:%M:%S")
            command_runtime = command_finish_time - command_start_time
            command_runtime = str(command_runtime.total_seconds() / 60)  # Command runtime in minutes
            command_runtime = command_runtime.split('.')[0] + '.' + command_runtime.split('.')[1][0:3] + ' minutes'
        modules_dict[command[4]]['commands'].append({
            'command_key': command[0],
            'executed_command': command[1],
            'command_output': command[2],
            'command_start_time': command[3],
            'command_finish_time': command[8],
            'module_specific_data': command[5],
            'command_title': command[6],
            'is_running': command[7],
            'total_runtime': command_runtime
        })
    # Adding it all to a list, so it's easier in the front end
    modules_list = []
    for module, module_details in modules_dict.items():
        modules_list.append(module_details)

    # Getting attack chain info
    attack_chain = cursor.execute("SELECT attack_chain_content FROM attack_chains WHERE attack_chain_parent=?",
                                  [host_key]).fetchall()[0][0]

    host_dict = {
        'name': host_details[0][0],
        'creationTime': host_details[0][2],
        'identifiers': host_details[0][1].split(','),
        'note': host_details[0][3],
        'key': host_key,
        'terminals': terminal_sessions_list,
        'modules': modules_list,
        'attack_chain': attack_chain
    }

    connection.close()
    return host_dict


def update_host_note(note_dict: dict):
    """
    Gets a dictionary containing the hosts key and the notes new value and updates it in the DB
    :param note_dict: A dictionary containing the hosts key and the notes new value
    :return: A message indicating what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure the given host exists
    r = cursor.execute("SELECT host_key FROM hosts WHERE host_key=?", [note_dict['key']]).fetchall()
    if len(r) != 1:
        connection.close()
        return 'The host whose note you wish to update, does not exist'

    # If the host does exist then update the note
    cursor.execute("UPDATE hosts SET note=? WHERE host_key=?", [note_dict['note_content'], note_dict['key']])
    connection.commit()
    connection.close()
    return 'note saved'


def delete_terminal(terminal_dict: dict):
    """
    Gets a dictionary containing the terminals key, and deletes it
    :param terminal_dict: A dictionary containing the terminals key
    :return: A message indicating what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure terminal exists
    r = cursor.execute("SELECT terminal_key FROM terminals WHERE terminal_key=? AND parent_host_key=?",
                       [terminal_dict['terminalKey'], terminal_dict['hostKey']]).fetchall()
    if len(r) != 1:
        connection.close()
        return "The terminal you are trying to delete does not exist"

    # If terminal exists
    cursor.execute("DELETE FROM terminals WHERE terminal_key=? AND parent_host_key=?",
                   [terminal_dict['terminalKey'], terminal_dict['hostKey']])
    connection.commit()
    connection.close()
    return 'Terminal Deleted'


def add_terminal(host_key):
    """
    Gets a host key and adds a new terminal to it
    :param host_key: The host we want to add a terminal to
    :return: A dictionary with all the terminals info
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure the host exists
    r = cursor.execute("SELECT host_key FROM hosts WHERE host_key=?", [str(host_key)]).fetchall()
    if len(r) != 1:
        connection.close()
        return 'The host you wish to create a terminal for does not exist'

    # Finding the smallest available terminal_key
    terminal_keys = cursor.execute("""SELECT terminal_key FROM terminals WHERE parent_host_key=?
    ORDER BY CAST(terminal_key as INTEGER) ASC""", [host_key]).fetchall()
    minimum_terminal_key = 1
    # If a terminal already exists
    if len(terminal_keys) > 0:
        for terminal in terminal_keys:
            datatype_key = int(terminal[0])
            # If this key is free it's the new terminal's key
            if minimum_terminal_key != datatype_key:
                break
            # If the key was taken then add one and try again
            minimum_terminal_key += 1
    terminal_creation_time = str(datetime.now()).split('.')[0]
    # Adding terminal
    cursor.executemany("INSERT INTO terminals VALUES (?,?,?,?,?)",
                       [(minimum_terminal_key, None, host_key, terminal_creation_time, None)])
    connection.commit()
    connection.close()
    return {
        "creation_time": terminal_creation_time,
        "last_session_time": None,
        "session_data": None,
        "terminal_key": minimum_terminal_key,
        "terminal_name": 'Terminal ' + str(minimum_terminal_key)
    }


def get_available_datatypes(host_key):
    """
    Gets a host key and returns all the datatypes available to use in the host.
    The host's identifiers,
    All string datatypes in the project,
    All file datatypes in the project
    :param host_key: The key of the requested host
    :return: A dictionary containing all the datatypes available to use in the host
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    host_details = cursor.execute("SELECT host_identifiers, parent_project FROM hosts WHERE host_key=?",
                                  [host_key]).fetchall()[0]

    if len(host_details) != 2:
        connection.close()
        return 'Requested host does not exist'

    datatypes_dict = {
        'Host': [],
        'File': [],
        'String': []
    }
    # Adding host identifiers
    host_identifiers = host_details[0].split(',')
    datatypes_dict['Host'] = host_identifiers
    # Getting datatypes associated to project
    parent_project = host_details[1]
    project_datatypes = cursor.execute("SELECT datatype, value FROM datatypes WHERE parent_project=?",
                                       [parent_project]).fetchall()

    for datatype in project_datatypes:
        if datatype[0] == 'String':
            datatypes_dict['String'].append(datatype[1])
        if datatype[0] == 'File':
            datatypes_dict['File'].append(ntpath.basename(datatype[1]))

    connection.close()

    return datatypes_dict


def update_project_note(note_dict: dict):
    """
    Gets a dictionary containing the projects key and the notes new value and updates it in the DB
    :param note_dict: A dictionary containing the hosts key and the notes new value
    :return: A message indicating what happened
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure the given host exists
    r = cursor.execute("SELECT project_key FROM projects WHERE project_key=?", [note_dict['key']]).fetchall()
    if len(r) != 1:
        connection.close()
        return 'The project whose note you wish to update, does not exist'

    # If the host does exist then update the note
    cursor.execute("UPDATE projects SET project_notes=? WHERE project_key=?",
                   [note_dict['note_content'], note_dict['key']])
    connection.commit()
    connection.close()
    return 'note saved'


def update_attack_chain(attack_chain_dict):
    """
    Gets a dictionary containing the updated attack chain info and the parent key and updates the attack chain
    :param attack_chain_dict: A dictionary containing the updated attack chain info
    :return: A message indicating what happened
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure the attack chain exists
    attack_chain = cursor.execute("SELECT attack_chain_parent FROM attack_chains WHERE attack_chain_parent=?",
                                  [attack_chain_dict['parentKey']]).fetchall()

    if len(attack_chain) != 1:
        connection.close()
        return 'The attack chain you wish to edit does not exist'

    # If attack chain exists update it
    cursor.execute("UPDATE attack_chains SET attack_chain_content=? WHERE attack_chain_parent=?",
                   [attack_chain_dict['content'], attack_chain_dict['parentKey']])
    connection.commit()
    connection.close()
    return 'attack chain updated'


def set_module_output_commands_finished_running():
    """This function goes over all the module output commands
    and sets the is_running column to False on every command.
    This is useful because if the program just started, no command could have been running before it.
    But if the user closed the program abruptly, some commands may still be written as running"""
    connection = sqlite3.connect(global_params.DB_PATH)
    cursor = connection.cursor()
    cursor.execute("UPDATE module_commands_outputs SET is_running=?", ['false'])
    connection.commit()
    connection.close()


def run_module_command(cmd_dict: dict):
    """
    Adds a new command to module output with default value
    :return: The new commands key, the shell executable and the working directory
    """
    connection = sqlite3.connect(global_params.DB_PATH)
    cursor = connection.cursor()

    # Making sure parent exists
    parent = cursor.execute("SELECT host_key FROM hosts WHERE host_key=?", [cmd_dict['parentKey']]).fetchall()
    if len(parent) != 1:
        connection.close()
        return "The host on which you want to run the command does not exist", None, None

    shell_settings = cursor.execute("""SELECT value FROM settings WHERE 
            setting='ShellWorkingDirectory' OR setting='Shell'""").fetchall()
    shell_executable = shell_settings[0][0]
    working_directory = shell_settings[1][0]

    # Finding the smallest available command_key
    command_keys = cursor.execute("""SELECT command_key FROM module_commands_outputs WHERE parent_host=? 
    AND module_key=? ORDER BY CAST(command_key as INTEGER) ASC""",
                                  [cmd_dict['parentKey'], cmd_dict['moduleKey']]).fetchall()
    minimum_command_key = 1
    # If a command already exists
    if len(command_keys) > 0:
        for command in command_keys:
            command_key = int(command[0])
            # If this key is free it's the new datatype key
            if minimum_command_key != command_key:
                break
            # If the key was taken then add one and try again
            minimum_command_key += 1
    # Getting current time
    command_execution_time = str(datetime.now()).split('.')[0]
    # Adding the new command to the db with default values
    cursor.executemany("INSERT INTO module_commands_outputs VALUES (?,?,?,?,?,?,?,?,?,?)",
                       [(minimum_command_key, cmd_dict['command'], '', cmd_dict['parentKey'], command_execution_time,
                         None, cmd_dict['moduleKey'], cmd_dict['commandTitle'], None, 'true')])
    connection.commit()
    connection.close()

    return minimum_command_key, shell_executable, working_directory


def update_module_command_output(cmd_dict: dict):
    """Will get info to update the modules command output after it finished running"""

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()
    # Check if command exists
    r = cursor.execute("""SELECT command_key FROM module_commands_outputs WHERE command_key=? AND parent_host=? 
    AND module_key=?""", [cmd_dict['commandKey'], cmd_dict['parentKey'], cmd_dict['moduleKey']]).fetchall()
    if len(r) != 1:
        connection.close()
        return 'Command key does not exist'

    # If command exists then update it
    # Getting current time
    command_completion_time = str(datetime.now()).split('.')[0]
    cursor.execute("""UPDATE module_commands_outputs SET command_output=?, finish_time=?, module_specific_data=?, 
                      is_running=? WHERE command_key=? AND parent_host=? AND module_key=?""",
                   [cmd_dict['commandOutput'], command_completion_time, cmd_dict['fileContent'], 'false',
                    cmd_dict['commandKey'], cmd_dict['parentKey'], cmd_dict['moduleKey']])
    connection.commit()
    connection.close()
    return 'Command output contents updated'


def get_command_output(cmd_key: str, module_key: str, parent_key: str):
    """
    Returns all the information regarding a specified module command
    :param cmd_key: The module command key
    :param module_key: The module key
    :param parent_key: The parent host key
    :return: A dictionary containing all the modules command details (exactly like the get host returns)
    """

    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    command = cursor.execute("""SELECT command_key, executed_command, command_output, start_time, 
    module_key, module_specific_data, command_title, is_running, finish_time
    FROM module_commands_outputs WHERE command_key=? AND module_key=? AND parent_host=?""",
                             [cmd_key, module_key, parent_key]).fetchall()
    connection.close()
    if len(command) != 1:
        return "could not find requested command"

    command = command[0]
    # Checking command runtime
    if command[8] is None or str(command[8]).replace(' ', '') == '':  # If command did not finish executing
        if command[7] == 'true':
            command_runtime = 'command is still running'
        else: # if command[7] == 'false':
            command_runtime = 'command interrupted'
    else:
        command_finish_time = datetime.strptime(command[8], "%Y-%m-%d %H:%M:%S")
        command_start_time = datetime.strptime(command[3], "%Y-%m-%d %H:%M:%S")
        command_runtime = command_finish_time - command_start_time
        command_runtime = str(command_runtime.total_seconds() / 60)  # Command runtime in minutes
        command_runtime = command_runtime.split('.')[0] + '.' + command_runtime.split('.')[1][0:3] + ' minutes'
    command_dict = {
        'command_key': command[0],
        'executed_command': command[1],
        'command_output': command[2],
        'command_start_time': command[3],
        'command_finish_time': command[8],
        'module_specific_data': command[5],
        'command_title': command[6],
        'is_running': command[7],
        'total_runtime': command_runtime
    }
    return command_dict


def delete_command(cmd_dict: dict):
    """
    Gets a dictionary containing the command key, module key, and parent key. Checks that the command is not running,
    and deletes the command from the db
    :param cmd_dict: A dictionary containing the command key, module key, and parent key
    :return: A message indicating what happened
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    command = cursor.execute("""SELECT is_running FROM module_commands_outputs WHERE command_key=? AND module_key=? 
    AND parent_host=?""", [cmd_dict['commandKey'], cmd_dict['moduleKey'], cmd_dict['parentKey']]).fetchall()
    if len(command) != 1:
        connection.close()
        return 'command does not exist'
    # Checking if the command is still running
    if command[0][0] == 'true':
        connection.close()
        return 'cannot delete, command is still running'

    cursor.execute("DELETE FROM module_commands_outputs WHERE command_key=? AND module_key=? AND parent_host=?",
                   [cmd_dict['commandKey'], cmd_dict['moduleKey'], cmd_dict['parentKey']])
    connection.commit()
    connection.close()
    return 'command deleted'


def add_command(cmd_dict: dict):
    """
    Gets information representing a command and manually adds it to the DB
    :param cmd_dict: A dictionary representing a module commands information
    :return: A message indicating what happened
    """
    connection = sqlite3.connect(global_params.DB_PATH)  # Connecting to db
    cursor = connection.cursor()

    # Making sure parent exists
    parent = cursor.execute("SELECT host_key FROM hosts WHERE host_key=?", [cmd_dict['parentKey']]).fetchall()
    if len(parent) != 1:
        connection.close()
        return 'The host you added the command to does not exist'
    # Making sure module exists
    module = cursor.execute("SELECT module_key FROM modules WHERE module_key=?", [cmd_dict['moduleKey']]).fetchall()
    if len(module) != 1:
        connection.close()
        return 'The module you added the command to does not exist'

    # Finding the smallest available command_key
    command_keys = cursor.execute("""SELECT command_key FROM module_commands_outputs WHERE parent_host=? 
    AND module_key=? ORDER BY CAST(command_key as INTEGER) ASC""",
                                  [cmd_dict['parentKey'], cmd_dict['moduleKey']]).fetchall()
    minimum_command_key = 1
    # If a command already exists
    if len(command_keys) > 0:
        for command in command_keys:
            command_key = int(command[0])
            # If this key is free it's the new datatype key
            if minimum_command_key != command_key:
                break
            # If the key was taken then add one and try again
            minimum_command_key += 1
    # Getting current time
    command_execution_time = str(datetime.now()).split('.')[0]
    # Adding the new command to the db with default values
    cursor.executemany("INSERT INTO module_commands_outputs VALUES (?,?,?,?,?,?,?,?,?,?)",
                       [(minimum_command_key, cmd_dict['command'], cmd_dict['content'], cmd_dict['parentKey'],
                         command_execution_time, command_execution_time, cmd_dict['moduleKey'],
                         cmd_dict['commandTitle'], None, 'false')])
    connection.commit()
    connection.close()
    return 'command added'
